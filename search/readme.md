# Поиск

Надо реализовать поисковую систему. На вход подается текст `text`, поисковый запрос `query` и число
`result_size`. Надо вернуть `result_size` строк из текста по убыванию релевантности.
Если две строки имеют одинаковую релевантность, надо вернуть их в том же порядке, в котором
они встречаются в тексте. Если нашлось меньше, чем `result_size` релевантных (с релевантностью > 0)
строк, то надо вернуть столько релевантных строк, сколько удалось найти.

## Алгоритм

Мерой релевантности будем считать сумму [TF-IDF](https://ru.wikipedia.org/wiki/TF-IDF) для уникальных слов, входящих в запрос. В этой задаче документом является строка, коллекцией документов - множество строк текста.

Алгоритм не должен быть чувствительным к регистру. Словом считается максимальная по включению непрерывная последовательность символов, удовлетворяющая критерию `std::isalpha()`.
Строки в тексте, не содержащие слов, игнорируются.

## Производительность

Учитывайте, что текст может быть достаточно большим. Постарайтесь избегать копирования строк везде, где это возможно.

## Пример

Расчет на примере [из тестов](test.cpp).

`IDF(typesetting) = 2/13` (есть в 2 из 13 строках текста)
`IDF(release) = 1/13`

Есть 3 строки, которые теоретически подходят под запрос:
1) `of the printing and typesetting industry.` `TF(typesetting) = 1/6` (одно слово из 6)
2) `electronic typesetting, remaining essentially` `TF(typesetting) = 1/4`
3) `the release of Letraset sheets containing Lorem` `TF(release) = 1/7`

Считаем TF-IDF
1) 1/6 * log(13/2) = 0.31
2) 1/4 * log(13/2) = 0.47
3) 1/7 * log(13) = 0.37

Правильный ответ - строка (2)
